"""
Cluster job
"""

import os
import subprocess
import sys
from typing import List

from psycopg2 import connect

from common.config import Config
from common.logging import get_logger
from common.logging import init_logging

CFG = Config()

LOGGER = get_logger(__name__)
PG_REPACK_ARGS = ["pg_repack", "-k", "-d", CFG.db_name, "-h", CFG.db_host, "-p", str(CFG.db_port), "-U", CFG.db_user]


def get_conn():
    """Returns DB connection"""
    return connect(
        dbname=CFG.db_name,
        user=CFG.db_user,
        password=CFG.db_pass,
        host=CFG.db_host,
        port=CFG.db_port,
        sslmode=CFG.db_ssl_mode,
        sslrootcert=CFG.db_ssl_root_cert_path,
    )


def launch_cluster(table: str, fields: List[str]):
    """Launches pg_repack to cluster table by given fields"""
    LOGGER.info("Clustering %s table by fields: %s", table, fields)
    fields_str = ",".join(fields)
    process = subprocess.Popen(PG_REPACK_ARGS + ["-t", table, "-o", fields_str], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    with process.stdout:
        for line in iter(process.stdout.readline, b""):
            LOGGER.info(line[: len(line) - 1].decode("utf-8"))
    if process.wait() != 0:
        LOGGER.error("pg_repack process returned non-zero code: %s. Exiting.", process.returncode)
        sys.exit(2)


def search_table_partitions(conn, table_like_name: str) -> List[str]:
    cur = conn.cursor()
    cur.execute(
        """
            SELECT tablename
            FROM   pg_indexes
            WHERE  tablename LIKE %s
            GROUP BY tablename
        """,
        (table_like_name,),
    )

    partitions = [res[0] for res in cur.fetchall()]
    conn.commit()
    cur.close()
    return partitions


def cluster_partitioned_table(partitions: List[str], cluster_fields: List[str]):
    """Cluster partitioned table by given fields"""
    for partition in partitions:
        launch_cluster(partition, cluster_fields)


def cluster_system_vulnerable_package(conn):
    """Cluster system_vulnerable_package table and its partitions"""
    partitions = search_table_partitions(conn, "system_vulnerable_package_%")

    LOGGER.info("Clearing %s system_vulnerable_package partitions", len(partitions))

    cluster_fields = ["rh_account_id", "system_id"]
    cluster_partitioned_table(partitions, cluster_fields)


def cluster_system_vulnerabilities(conn):
    """Cluster system_vulnerabilities table by given fields"""
    partitions = search_table_partitions(conn, "system_vulnerabilities_active_%")

    LOGGER.info("Clearing %s system_vulnerabilities partitions", len(partitions))

    cluster_fields = ["rh_account_id", "cve_id"]
    cluster_partitioned_table(partitions, cluster_fields)


def cluster() -> None:
    """Cluster system_platform and all system_vulnerabilities_active_* tables"""
    LOGGER.info("Starting cluster job")

    os.environ["PGPASSWORD"] = CFG.db_pass

    conn = get_conn()
    cur = conn.cursor()

    LOGGER.info("Checking pg_repack extension in DB")
    cur.execute("""SELECT default_version, installed_version FROM pg_available_extensions WHERE name = 'pg_repack'""")
    row = cur.fetchone()
    conn.commit()
    if row:
        default_version, installed_version = row
        if installed_version != default_version:
            if installed_version:
                LOGGER.info("Dropping existing pg_repack extension version %s", installed_version)
                cur.execute("""DROP EXTENSION pg_repack""")
            LOGGER.info("Creating pg_repack extension version %s", default_version)
            cur.execute("""CREATE EXTENSION pg_repack""")
            conn.commit()
        else:
            LOGGER.info("pg_repack extension version %s already exists", installed_version)
    else:
        LOGGER.error("pg_repack extension is not available")
        sys.exit(1)

    launch_cluster("system_platform", ["rh_account_id"])
    launch_cluster("cve_metadata", ["impact_id"])
    cluster_system_vulnerabilities(conn)
    cluster_system_vulnerable_package(conn)

    conn.close()
    LOGGER.info("Finished cluster job")


if __name__ == "__main__":
    init_logging()
    cluster()
